%!TEX root = ../main.tex
% !TeX spellcheck = en_GB 


\chapter{Implementation}

The objective of this thesis was to implement and evaluate a  collision avoidance  algorithm for USVs. Several related approaches where analysed before the fuzzy logic approach presented by \textcite{perera2012intelligent}, was chosen to be implemented.
The solution presented in the original paper is implemented in MATLAB, while the solution presented here is implemented in Python. Python was chosen due to the writers previous knowledge of the language as well as the availability of fuzzy logic python libraries. The library used in this implementation is called SciKit-Fuzzy \cite{josh_warner_2017_1002946}.

\section{The fuzzy inference system}
Scikit fuzzy provides a simple application programming interface to setup a FIS. This section will describe the process setting up a simple FIS that calculates salary based on age and the amount of previous jobs. Fuzzy sets for age are set up int the same way as in \ref{sec:fuzzy_sets}, but with age ranges more appropriate for the example. The sets are therefore young = 18 - 35, middle aged = 30 - 50, and old 45-65.  Additionally job and salary sets are introduced. Line 4-6 in listing \ref{listing:fis} initializes the universes for the different fuzzy sets. These are 18-100 for age and 0-10 for jobs, both with a step of 1. Age and jobs acts as antecedents in the FIS and the initialization call is therefore to  \texttt{ctrl.Antecedent} Salary goes from 1500-10000 with steps of 500 and acts as consequent and is therefore initialized with  \textit{ctrl.Consequent}. The numbers used are made up for the sake of the example.

Next the membership functions are initialized in lines 7-15. The age sets are defined  on lines 7-9 as described above.
Three different job sets are defined: \textit{few} (<3),  \textit{medium} (2-6), and \textit{many} (>5). The salary sets are \textit{low} (1500 - 2500),  \textit{medium} (2000-7000), and \textit{high} (<6000). All sets are initialized using \texttt{fuzz.trimf} which produces a triangular membership function. The resulting FMF are visualized in figure \ref{fig:fmf_ex3}

Next the following rules are defined, on lines 16 -21 , to connect the antecedents with the consequents:

\begin{enumerate}[label=\textbf{Rule \arabic*},ref=Rule \arabic*]
    \item IF young  OR few jobs THEN salary is low
    \item IF middle aged  AND few jobs THEN salary is low
    \item IF middle aged  OR medium amount of  jobs THEN salary is medium
    \item IF middle aged  AND many jobs THEN salary is high
    \item IF old  OR many jobs THEN salary is high
\end{enumerate}

Finally the rules are passed to the Control System on line 25  and  \\ \texttt{ctrl.ControlSystemSimulation} is called to complete the FIS initialization.
The system is now ready to take input and calculate output based on the rule set specified. An example using age = 35 and jobs = 1 is input on lines 25-28 and the output printed on lines 30-32. The example outputs a salary of 4157.4.


\begin{figure}[h]
    \begin{tabular}{cc}

        \subfloat[Age antecedent]{
            \includegraphics[width=0.5\textwidth,height=0.42\textheight,keepaspectratio]{Figures/age_ex}
            \label{fig:age_ex}
        } &
        \subfloat[Jobs antecedent]{
            \includegraphics[width=.49\linewidth,height=0.42\textheight,keepaspectratio]{Figures/jobs_ex}
            \label{fig:jobs_ex}
        }   \\
        \multicolumn{2}{c}{\subfloat[Salary consequent]{
                \includegraphics[width=\linewidth,height=0.42\textheight,keepaspectratio]{Figures/salary_ex}
                \label{fig:salary_ex}
            }}
    \end{tabular}

    \caption{FMSs used in example FIS}
    \label{fig:fmf_ex3}
\end{figure}


\begin{listing}[h]
    \inputminted[linenos, breaklines=true,fontsize=\scriptsize, numberblanklines=false]{python}{../src/example.py}
    \caption{FIS initialization}
    \label{listing:fis}
\end{listing}

\section{Architecture}
This section will present the high level structure of the implementation with the help of the class diagram seen in figure \ref{fig:class_diagram}. Each class and their interactions will be briefly presented.
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth,height=0.75\textheight,keepaspectratio]{../src/classes_Pyreverse}
    \caption{Class diagram}
    \label{fig:class_diagram}
\end{figure}
\subsection{Classes}
Each simulation scenario consists of at least one vessel. These vessels are represented by the \textit{Vessel} class. The current state of the vessel is represented by the \textit{ShipState} class which also contains the \textit{Position} class. Furthermore, each vessel need a navigation system, which is represented by the \textit{AutonomousNavigationSystem} class. The classes will be more thoroughly presented in the following subsections.
\subsubsection{Vessel}
\textit{Vessel} is the main class and the class with which the simulation script interacts.
It contains, apart from the previously mentioned \textit{AutonomousNavigationSystem} and \textit{ShipState} an id and a method to calculate its position in the next time frame.
A new vessel object in created with the following call:
\begin{minted}{python}
Vessel(id, heading, position_x, position_y, speed, max_speed, 
    rate_of_turn, fuzzy_inference_system, auto_pilot)
\end{minted}
This constructor call specifies the ID for the vessel as well as its initial position, speed and heading. Furthermore it defines the vessels maximum speed and rate of turn. The two final parameters specify the fuzzy inference system to use and whether the vessel shall use the navigation system. Setting the final boolean to false creates a rogue vessel that will just keep its initial speed and heading, thereby not complying to the COLREG rules. The \textit{Vessel} class has only one method, which calculates the vessels position in the next time frame after applying possible corrections to heading ans speed.
\subsubsection{Position}
The position class simply holds the vessels current coordinates in the Cartesian coordinate system used.
\subsubsection{ShipState}
ShipState holds information about the state of the vessel in the current time frame. This includes the vessels current position, heading and speed. The simulation does not distinguish between course and heading since no drift is simulated.
Furthermore, limits such as maximum allowed speed and standard rate of turn is specified in this class. Finally, the class holds methods to change the ships heading by the specified standard rate of turn or speed by 1 kt, for the next time frame.


\subsubsection{AutonomousNavigationSystem}
\label{sec:ANS}
The AutonomousNavigationSystem class from now on referred to as ANS is what separates an autonomous vessel from an ordinary vessel. The ANS combines the information from the ShipState class with situational awareness information provided by a separate Situational Awareness (SA) module, in order to calculate needed corrections to speed and course.

The SA is in this simulation case represented by a service that holds all information regarding the current scenario. A real system would have a SA module that reads and processes information from different sensors, such as LiDAR, cameras, on board the vessel. Information needed about a target vessel is its heading, speed, and position. These are used to calculate the four different inputs to the FIS system. Listing \ref{listing:rel_bear_calc} shows the method used to calculate the relative bearing fed into the FIS system. Compass bearing is first calculated from the two provided coordinate pairs after which the result is converted into a relative bearing. Relative course is then calculated as the observed vessels heading - the own vessels heading, as shown in listing \ref{listing:rel_course_calc}. Distance can be obtained by using the Pythagorean theorem on the differences between the vessels in the X and Y axis. Finally speed ratio is defined as $\frac{\text{Speed of the observed vessel}}{\text{Speed of the own vessel}}$.
\begin{listing}

    \begin{minted}[linenos, breaklines=true,fontsize=\scriptsize, numberblanklines=false]{python}
rel_course = observed_vessel.shipstate.heading - shipstate.heading
if rel_course < 0:
    rel_course = 360 + rel_course
    \end{minted}
    \caption{Relative course calculation}
    \label{listing:rel_course_calc}
\end{listing}

These inputs are fed into the FIS system, for each target vessels, and the recommended corrections presented by FIS are stored in an array. The expected time until collision for each target vessel is also calculated . Knowing the distance between the vessels, their relative velocity is needed to calculate the time. Equation \ref{eq:rel_vel_calc} shows the relative velocity calculation, based on the law of Cosines. \textit{V} stands for velocity, $\theta$ for heading, the subscript \textit{m} for own vessel and \textit{t} for target vessel.

\begin{equation}
    V_r=\sqrt{V_m^2 + V_t^2-2  V_mV_tcos(\theta_m-\theta_t)}
    \label{eq:rel_vel_calc}
\end{equation}

The previous calculations results in speed and heading correction suggestions, as well as an expected time until collision, for each target vessel. However, these recommendations might contradict each other and a way to prioritize the corrections in order of urgency is therefore needed. This is in this implementation solved in a simple matter by calculating the weighted arithmetic mean of the corrections using the expected time until collision as weight. The resulting corrections are then stored in ShipState as target heading.

Finally the heading and speed of the vessel is updated in the following manner. The vessels is steered towards the proposed heading change by a maximum of the vessels defined maximum rate of turn. The speed is similarly changed towards the proposed speed by a maximum of one knot. No proposed correction by the FIS means that the vessel is currently not in a scenario that satisfies a rule in the rule set. However, a previous correction suggestion might still not be completed due to the vessels limited rate of turn, acceleration or deceleration.  The vessel will therefore continue to change its heading and speed towards the saved target speed until they are the same.  The target heading is then gradually changed towards the original heading until the vessel is back on its original heading. The process is visualized in Figure \ref{fig:flow_chart}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth,height=0.75\textheight,keepaspectratio]{Figures/flow.png}
    \caption{Flow chart explaining application of heading and speed corrections}
    \label{fig:flow_chart}
\end{figure}

\section{Simulation}
\todo{Present values used for parameters. Ex. $R_a, R_b$  and sectors}
The goal of the implementation is to  simulate a real world situation with respect to time, speed, acceleration, and rate of turn, while neglecting  environmental factors such as weather.
The simulation is therefore limited to two dimensions in a Cartesian coordinate system.
The interval between time frames in the simulation is set to correspond to one second in the real world.
Each iteration of the main simulation loop must, therefore, update the vessels SA by scanning the environment for target vessels. The information gained is then fed into the FIS which generates the course and speed corrections used to update heading and speed as explained in section \ref{sec:ANS}.
